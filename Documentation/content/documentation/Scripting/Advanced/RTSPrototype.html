<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<HEAD><SCRIPT SRC="../../../include/tutorial.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/prototype.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/scriptaculous.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/glossaryLookUp.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/referenceLookUp.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/component.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT SRC="../../../include/componentContainer.js" LANGUAGE="JavaScript"></SCRIPT>
<SCRIPT>DocImagePath = "../../../";</SCRIPT><link href="../../../include/tutorialStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/tutorial.css" rel="stylesheet" type="text/css" />
<link href="../../../include/globalMainPageStyles.css" rel="stylesheet" type="text/css" />
<link href="../../../include/referenceThemeStyle.css" rel="stylesheet" type="text/css" />
<link href="../../../include/docTheme/theme.css" rel="stylesheet" type="text/css" />
<script>
   // this script chunk is to update the ToC to the current doc and expand it
   pageID = 85;
   parent.leftFrame.expandToItem('tree2', 'doc85');
   var element = parent.leftFrame.document.getElementById('doc85');
   if((element) && (element.className==parent.leftFrame.nodeClosedClass))
{
   element.className = parent.leftFrame.nodeOpenClass
}
;
</script>
<link rel="stylesheet" type="text/css" href="../../../include/container.css" />
<link rel="stylesheet" type="text/css" href="../../../include/content.css" />
<title>Torque3D - RTS Prototype</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    </head>
<BODY id = "BODYID" onLoad = "initComponent()"  bgcolor="#FFFFFF" class="mediawiki ltr ns-0 ns-subject page-Torque3D_Scripting_Advanced_RTSPrototype skin-monobook">
<table width="700" cellspacing="0" cellpadding="0" border="0" style="text-align: justify;" xmlns="">
<tr>
<td width="700">

<div id="globalWrapper" xmlns="http://www.w3.org/1999/xhtml">
  <div id="column-content">
    <a name="top" id="top"></a>
      
        <table border="0" cellpadding="15" cellspacing="0" width="700">
          <tbody>
            <tr>
              <td width="700"><table id="toc" summary="Contents">
                  <tbody>
                    <tr>
                      <td><div id="toctitle">
                          <h2>Contents</h2>
                        <ul>
                          <li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
                          <li class="toclevel-1"><a href="#Create_Project"><span class="tocnumber">2</span> <span class="toctext">Create A New Project</span></a></li>
                          <li class="toclevel-1"><a href="#First_Step"><span class="tocnumber">3</span> <span class="toctext">First Steps</span></a></li>
                          <li class="toclevel-1"><a href="#Camera_Setup"><span class="tocnumber">4</span> <span class="toctext">Camera Setup</span></a></li>
                          <li class="toclevel-1"><a href="#Mouse_Setup"><span class="tocnumber">5</span> <span class="toctext">Mouse Setup</span></a>
                            <ul>
                              <li class="toclevel-2"><a href="#Mouse_Cursor_Toggling"><span class="tocnumber">5.1</span> <span class="toctext">Mouse Cursor Toggling</span></a></li>
                              <li class="toclevel-2"><a href="#Mouse_Click_Reaction"><span class="tocnumber">5.2</span> <span class="toctext">Placing Structures Using The GUI</span></a></li>
                            </ul>
                          </li>
                          <li class="toclevel-1"><a href="#Mouse-Driven_Input"><span class="tocnumber">6</span> <span class="toctext">Mouse-Driven Input</span></a>
                            <ul>
                              <li class="toclevel-2"><a href="#Player_Spawning"><span class="tocnumber">6.1</span> <span class="toctext">Player Spawning</span></a></li>
                              <li class="toclevel-2"><a href="#Movement"><span class="tocnumber">6.2</span> <span class="toctext">Movement</span></a></li>
                              <li class="toclevel-2"><a href="#Spawning_Enemy_Targets"><span class="tocnumber">6.3</span> <span class="toctext">Spawning Enemy Targets</span></a></li>
                              <li class="toclevel-2"><a href="#Attacking"><span class="tocnumber">6.4</span> <span class="toctext">Attacking</span></a></li>
                              <li class="toclevel-2"><a href="#Tweaking_Attacks"><span class="tocnumber">6.5</span> <span class="toctext">Tweaking Attacks</span></a></li>
                            </ul>
                          </li>
                          <li class="toclevel-1"><a href="#Destination_Markers"><span class="tocnumber">7</span> <span class="toctext">Destination Markers</span></a>
                            <ul>
                              <li class="toclevel-2"><a href="#Creating_a_Material"><span class="tocnumber">7.1</span> <span class="toctext">Creating a Material</span></a></li>
                              <li class="toclevel-2"><a href="#Creating_a_Decal"><span class="tocnumber">7.2</span> <span class="toctext">Creating a Decal</span></a></li>
                              <li class="toclevel-2"><a href="#Spawning_the_Marker"><span class="tocnumber">7.3</span> <span class="toctext">Spawning the Marker</span></a></li>
                              <li class="toclevel-2"><a href="#Erasing_the_Marker"><span class="tocnumber">7.4</span> <span class="toctext">Erasing the Marker</span></a></li>
                            </ul>
                          </li>
                          <li class="toclevel-1"><a href="#Camera_Modes"><span class="tocnumber">8</span> <span class="toctext">Camera Modes</span></a>
                            <ul>
                              <li class="toclevel-2"><a href="#Orbit_Camera"><span class="tocnumber">8.1</span> <span class="toctext">Orbit Camera</span></a></li>
                              <li class="toclevel-2"><a href="#Overhead_Camera"><span class="tocnumber">8.2</span> <span class="toctext">Overhead Camera</span></a></li>
                            </ul>
                          </li>
                          <li class="toclevel-1"><a href="#GoingRTS"><span class="tocnumber">9</span> <span class="toctext">Going More Real-Time Strategy</span></a></li>
                          <li class="toclevel-1"><a href="#Conclusion"><span class="tocnumber">10</span> <span class="toctext">Conclusion</span></a></li>
                        </ul></td>
                    </tr>
                  </tbody>
                </table>
                <h1> <span class="mw-headline">RTS Prototype: Part 1</span></h1>
                <a name="Introduction" id="Introduction"></a>
                <h2> <span class="mw-headline">Introduction</span></h2>
                <p>Torque 3D's stock demos and templates are setup for first person
                  shooter (FPS) games. However, the engine has multiple camera modes that
                  can change the perspective and how the game is controlled. In this
                  tutorial, we are going to modify the camera and mouse controls to
                  emulate different game types: Hack &amp; Slash and RTS. </p>
                <p>Some of the topics that will be covered are: </p>
                <ul>
                  <li>Advanced scripting </li>
                  <li>Camera manipulation </li>
                  <li>Simple AI unit navigation</li>
                  <li>Object spawning </li>
                  <li>Mouse and keyboard input </li>
                  <li>Basic RTS and Hack &amp; Slash mechanics </li>
                </ul>
                <p><br />
                  Before you begin, you should be familiar with the following guides. Make sure you have read these before proceeding: </p><br />
                <ul>
                  <li>TorqueScript Syntax </li>
                  <li>Camera Modes </li>
                  <li>World Editor Interface </li>
                  <li>Adding 3D Shapes </li>
                  <li>Material Editor </li>
                  <li>Decal Editor </li>
                  <li>Datablock Editor </li>
                </ul>
                <p>
                      <h5>NOTE:  Changes between Torque 3D MIT 3.0 and 3.5 have broken this prototype.</h5>
                    <p>
                        <em>If you are using Torque 3D MIT 3.5 or later you will need to be intimately familiar with Torque 3D and the changes
                        that were made between the 3.0 and 3.5 releases.  The premade scripts that are provided have been reported to function
                        incorrectly when transplanted directly and would need extensive debugging to get them working properly.</em>
                    </p>
                    <p>
                        <em>You have been warned.</em>
                    </p>
                </p>
                <a name="Create_Project" id="A2"></a>
                <h2> <span class="mw-headline">Create A Fresh Project</span></h2>
                <p>We&#39;re going to start with a clean project. &nbsp;I usually do this manually using the following steps: </p>
<p>
<ol>
	<li>Copy the Full folder from <strong>Templates</strong> to <strong>My Projects</strong>.</li>
    <li>Rename the Full folder.  In this instance, rename it to RTSProto.</li>
    <li>Rename the <strong>game/Full.torsion</strong> file to match my project folder (RTSProto).</li>
    <li>Edit the <strong>buildFiles/config/project.conf</strong> file:</li>
    <ol type="a">
    	<li>Change the project name in the <strong>Torque3D::beginConfig</strong> line to match your project (RTSProto).</li>
        <li>Add the navigation module by adding <strong>includeModule( 'navigation' );</strong> inside the config block.</li>
    </ol>
    <li>Run the <strong>generateProjects.bat</strong> file to generate the updated solution and project files.</li>
    <li>Build the project in your preferred compiler.</li>
</ol>
<br/>
<p>
                  The Full Template used for this tutorial project should contain base art and scripts needed to run the game.  We will be creating a few custom assets for the project as 
                  we go along.</p>

<br />
                <a name="First_Step" id="First_Step"></a>
                <h2> <span class="mw-headline">First Steps</span></h2>
<h3> <span class="mw-headline">Navigation</span></h3>
<p>We need to add a navigation mesh to our mission so that we know where we can place buildings and to allow units to path correctly around the mission 
area.  Start the game and open <strong>Empty Terrain.mis</strong> in the World Editor.  Once it is open, select the <strong>Mission Area Editor</strong> from 
the Editor rollout:
</p>
<p>
  <img alt="" src="images/RTS_CreateMissionArea.png" /></p>
<p>Next, adjust the mission area to fill most of the map by dragging the red corner nodes:
</p>
<p>
  <img alt="" src="images/RTS_FitMissionArea.png" /></p>
<p>Then select the <strong>Navigation Editor</strong> from the Editor rollout:
</p>
<p>
  <img alt="" src="images/RTS_CreateNavMesh.png" /></p>
<p>In the New NavMesh dialog, set the name to <strong>NavEmptyTerrain</strong> and select both <strong>Fit NavMesh to mission area</strong> and <strong>Include terrain</strong>.  Finally, click the <strong>Create!</strong> button.</p>
<p>
  <img alt="" src="images/RTS_NavCreationSettings.png" /></p>
<p>Now we need to configure and build the navigation mesh.  Set the <strong>name</strong> to <strong>NavEmptyTerrain</strong>, the <strong>fileName</strong> to <strong>levels/NavEmptyTerrain.nav</strong>, update the <strong>scale</strong> so that the third element (z) is around 500(just to be sure all objects added later are correctly added to the nav mesh), and the <strong>walkableSlope</strong> to <strong>36</strong> (our player datablock sets the maximum walkable slope to 38 degrees).  Then select <strong>Play sound when done</strong> and click the <strong>Build NavMesh</strong> button.  This will take a few minutes.</p>
<p>
  <img alt="" src="images/RTS_NavSettings.png" /></p>
 <p>You should now have a navigation mesh that covers the entire mission area.</p>
<h3> <span class="mw-headline">Loadout</span></h3>
<p>Now, in <strong>scripts/server/gameDM.cs</strong> we&#39;ll change the default player class and 
    datablock.&nbsp; In <strong>DeathMatchGame::initGameVars()</strong> make the 
    following change:</p>
<pre>
    $Game::DefaultPlayerClass = "AiPlayer";
    $Game::DefaultPlayerDataBlock = "DemoPlayer";
</pre>
<p>This gives us the ability to tell our unit where to go and let the AI class 
    handle getting it there.</p>
<p>Now open <strong>art/datablocks/aiPlayer.cs</strong> and update DemoPlayer to look like this:
<pre>datablock PlayerData(DemoPlayer : DefaultPlayerData)
{
   shootingDelay = 2000;
   mainWeapon = Lurker;
};</pre>    
<p>Next, in <strong>game/scripts/server/gameCore.cs</strong> find <strong>GameCore::loadOut()</strong> and comment out all of the
    weapons except the Lurker.  Then mount the Lurker to slot 0 instead of the Ryder.
</p>
                  <pre>
function GameCore::loadOut(%game, %player)
{
   //echo (%game @"\c4 -> "@ %game.class @" -> GameCore::loadOut");

   %player.clearWeaponCycle();
   
   //%player.setInventory(Ryder, 1);
   //%player.setInventory(RyderClip, %player.maxInventory(RyderClip));
   //%player.setInventory(RyderAmmo, %player.maxInventory(RyderAmmo));
   //%player.addToWeaponCycle(Ryder);

   %player.setInventory(Lurker, 1);
   %player.setInventory(LurkerClip, %player.maxInventory(LurkerClip));
   %player.setInventory(LurkerAmmo, %player.maxInventory(LurkerAmmo));
   %player.addToWeaponCycle(Lurker);

   //%player.setInventory(LurkerGrenadeLauncher, 1);
   //%player.setInventory(LurkerGrenadeAmmo, %player.maxInventory(LurkerGrenadeAmmo));
   //%player.addToWeaponCycle(LurkerGrenadeLauncher);

   //%player.setInventory(ProxMine, %player.maxInventory(ProxMine));
   //%player.addToWeaponCycle(ProxMine);

   //%player.setInventory(DeployableTurret, %player.maxInventory(DeployableTurret));
   //%player.addToWeaponCycle(DeployableTurret);
   
   if (%player.getDatablock().mainWeapon.image !$= "")
   {
      %player.mountImage(%player.getDatablock().mainWeapon.image, 0);
   }
   else
   {
      %player.mountImage(Lurker, 0);
   }
}                 </pre>
<p>Now our character will spawn with only the lurker in its inventory and will equip it automatically.</p>
<br />
<a name="Camera_Setup" id="A1"></a>
<h2> <span class="mw-headline">Camera Setup</span></h2>
<p>There are several camera modes available in Torque 3D that are generally unused because most people associate the engine with first person shooters.  While the examples and general designe of the engine are pre-disposed toward this, there are many features that let us break out of that mold.  Changing the camera modes is a good place to break out of the obvious FPS box.</p>
<h3> <span class="mw-headline">A note on server and client command functions</span></h3>
<hr />
<p>There are several instances where you will use the <strong>commandToServer()</strong> and <strong>commandToClient()</strong> functions.  The remote function you wish to call must be prefixed with "serverCmd" or "clientCmd".  The first argument is the name of the remote command you wish to call <em>without</em> the related prefix, and that name <em>must</em> be quoted with single quotes.  For example:</p>
<pre>// a server command - these are usually placed in scripts/server/commands.cs
serverCmdmyCommand(%client){ // do something here }

// from a client-side script
commandToServer('myCommand'); // note ' instead of "
</pre>
<p>Additionally, you can generally separate client and server scripts by their folder locations.  Client-side scripts are in <strong>scripts/client</strong> and <strong>scripts/gui</strong> (GUI scripts are client-side by nature) and server scripts are in <strong>scripts/server</strong>.  Game assets and datablocks are all loaded server-side and verified client-side at game start.  This also applies to the content of the <strong>core</strong> folder.</p>
<hr /><br />
<p>First we're going to set up our camera mode framework.  In <strong>
    scripts/server/commands.cs</strong> we&#39;re going to add some functions to set and 
    toggle our camera modes.  The following code can be added to the end of the script file: </p>
<pre>
// ----------------------------------------------------------------------------
// Camera commands
// ----------------------------------------------------------------------------

function serverCmdorbitCam(%client)
{
    orbitCam(%client);
}

function orbitCam(%client)
{
    %client.camera.setOrbitObject(%client.player, mDegToRad(20) SPC "0 0", 0, 5.5, 5.5);
    %client.camera.camDist = 5.5;
    %client.camera.controlMode = "OrbitObject";
}

function serverCmdoverheadCam(%client)
{
    overheadCam(%client);
}

function overheadCam(%client)
{
    %client.camera.position = VectorAdd(%client.player.position, "0 0 30");
    %client.camera.lookAt(%client.player.position);
    %client.camera.controlMode = "Overhead";
}

function serverCmdtoggleCamMode(%client)
{
    toggleCamMode(%client);
}

function toggleCamMode(%client)
{
    if(%client.camera.controlMode $= "Overhead")
        orbitCam(%client);
    else if(%client.camera.controlMode $= "OrbitObject")
        orbitCam(%client);
}

function serverCmdadjustCamera(%client, %adjustment)
{
    adjustCamera(%client, %adjustment);
}

function adjustCamera(%client, %adjustment)
{
    if(%client.camera.controlMode $= "OrbitObject")
    {
        if(%adjustment == 1)
            %n = %client.camera.camDist + 0.5;
        else
            %n = %client.camera.camDist - 0.5;
        
        if(%n < 0.5)
            %n = 0.5;
        
        if(%n > 15.0)
            %n = 15.0;
        
        %client.camera.setOrbitObject(%client.player, %client.camera.getRotation(), 0, %n, %n);
        %client.camera.camDist = %n;
    }
    if(%client.camera.controlMode $= "Overhead")
        %client.camera.position = VectorAdd(%client.camera.position, "0 0" SPC %adjustment);
}</pre>
<p>Additionally, in <strong>scripts/client/default.bind.cs</strong> we&#39;ll add some 
    keybinds and utility functions to assist in controlling the camera:</p>
<pre>
function toggleCameraMode(%val)
{
   if (%val)
      commandToServer('toggleCamMode');
}

moveMap.bind( keyboard, &quot;ctrl m", toggleCameraMode);

function mouseZoom(%val)
{
   if(%val > 0)
   {
      commandToServer('adjustCamera', -1);
   }
   else
   {
      commandToServer('adjustCamera', 1);
   }
}

moveMap.bind(mouse, "zaxis", mouseZoom);</pre>
<p>
	Now we have to track down references to <strong>Reticle</strong> and <strong>zoomReticle</strong> in <strong>scripts/client/default.bind.cs</strong> (while we're here) and <strong>scripts/client/client.cs</strong> just to clean up console errors:
</p>
<pre>
// in scripts/client/default.bind.cs
function turnOffZoom()
{
   ServerConnection.zoomed = false;
   setFov(ServerConnection.getControlCameraDefaultFov());
   //Reticle.setVisible(true);
   //zoomReticle.setVisible(false);

   // Rather than just disable the DOF effect, we want to set it to the level's
   // preset values.
   //DOFPostEffect.disable();
   ppOptionsUpdateDOFSettings();
}
</pre>
<pre>
// in scripts/client/client.cs
function clientCmdRefreshWeaponHUD(%amount, %preview, %ret, %zoomRet, %amountInClips)
{
   if (!%amount)
      AmmoAmount.setVisible(false);
   else
   {
      AmmoAmount.setVisible(true);
      AmmoAmount.setText("Ammo: " @ %amount @ "/" @ %amountInClips);
   }

   if (%preview $= "")
      WeaponHUD.setVisible(false);//PreviewImage.setVisible(false);
   else
   {
      WeaponHUD.setVisible(true);//PreviewImage.setVisible(true);
      PreviewImage.setbitmap("art/gui/weaponHud/"@ detag(%preview));
   }

   if (%ret $= "")
   {
      // Add braces to avoid parse error - or remove this block entirely
      //Reticle.setVisible(false);
   }
   else
   {
      //Reticle.setVisible(true);
      //Reticle.setbitmap("art/gui/weaponHud/"@ detag(%ret));
   }

   if (isObject(ZoomReticle))
   {
      if (%zoomRet $= "")
      {
         ZoomReticle.setBitmap("");
      }
      else
      {
         ZoomReticle.setBitmap("art/gui/weaponHud/"@ detag(%zoomRet));
      }
   }
}
</pre>
<p>Ensure that any other binds for <strong>zaxis</strong> and <strong>alt m</strong> 
    are commented out to avoid conflicts.&nbsp; Also, if the file <strong>
    scripts/client/config.cs</strong> exists it will need to be deleted before 
    changes to <strong>default.bind.cs</strong> can take effect.</p>
                <br />
                <h2> <span class="mw-headline">Mouse Setup</span></h2>
                <p>The following code will change the way mouse input affects movement and click interaction. </p><br />
                <a name="Mouse_Cursor_Toggling" id="Mouse_Cursor_Toggling"></a>
                <h3> <span class="mw-headline">Mouse Cursor Toggling</span></h3>
                <p>Normally, the camera is controlled by an actor in FPS (aim) mode. To
                  focus on just mouse and camera work, we need to change how the default
                  camera is controlled. Open <b>game/scripts/server/gameCore.cs</b>. In function <b>GameCore::preparePlayer(%game, %client)</b>, locate the following line: </p>
                <pre>%game.spawnPlayer(%client, %playerSpawnPoint);</pre>
                <p><br />
                  Change this code by adding a third argument to the function call: </p>
                <pre>%game.spawnPlayer(%client, %playerSpawnPoint, false);</pre>
                <p><br />
                  The function call being modified is <b>GameCore::spawnPlayer(%game, %this, %spawnPoint, %noControl)</b>, located in <b>game/scripts/server/gameCore.cs.</b> The last two arguments determine the location of spawning (%spawnPoint) and
                  whether or not the actor object controls the camera (%noControl). We need to address that next.</p>
                <p>Immediately below the <strong>%game.spawnPlayer()</strong> function, add the following code:</p>
<pre>
   // Set camera to Overhead mode   
   commandToServer('overheadCam');
</pre>
                <p>If you run the game, you will now be using an overhead camera instead of an FPS view controlled by the actor. Next, we need to
                  be able to control the on/off state of the in-game mouse cursor. Open <b>game/scripts/client/default.bind.cs</b>.  At the end of the file, add the following: </p>
                <pre>// Turn mouse cursor on or off
// If %val is true, the button was pressed in
// If %val is false, the button was released
function toggleMouseLook(%val)
{
   // Check to see if button is pressed
   if(%val)  
   {
      // If the cursor is on, turn it off.
      // Else, turn it on
      if(Canvas.isCursorOn())
         hideCursor();
      else
         showCursor();
   }
}

// Bind the function toggleMouseLook to the keyboard 'm' key
moveMap.bind(keyboard, "m", "toggleMouseLook");
</pre>
                <p><br />
                  Next, open your file browser and delete <b>scripts/client/config.cs</b>,
                  if it exists. This file contains custom keybinds created for your game.
                  It will override the variables and functions you add to <strong>default.bind.cs</strong>.
                  However, if you delete this file and run your game, a new one will be
                  regenerated with your updated keybinds. </p>
                <p><br />
                  If you start the game now, it will still default to an overhead camera. By hitting the 'm' key you will be able to toggle "mouse
                  look" mode. If mouse look is on, you can control your view direction by moving the mouse. If it is off, you can move your cursor around on the
                  screen. You can switch back to an actor controlled camera by pressing <strong>Alt + C</strong>. </p>
                <p><br />
                  We will go ahead and force the cursor to be on as soon as the level loads. Open <b>game/art/gui/playGui.gui</b>. You can edit .gui files just like any other script file. Look for the <b>noCursor</b> field. Make the following change to this field: </p>
                <pre>noCursor = "0";
</pre>
                <p><br />
                  Now that you've freed up the mouse from aiming duties, it's time to put it to other uses. </p><br />
                <a name="Mouse_Click_Reaction" id="Mouse_Click_Reaction"></a>
                <h3> Placing Structures Using The GUI</h3>
                  <p>First, open the GUI Editor from the main menu by clicking the GUI Editor button, by pressing <strong>F10</strong>, or by clicking the GUI Editor 
                      button from within the World Editor.</p>
                  <p>
                      <img alt="" src="images/RTS_OpenGUIEditor.png" /></p>
                  <p><br />
                      Open the <strong>PlayGui</strong> gui by clicking the GUI collection dropdown and selecting it from the list.</p>
                  <p>
                      <img alt="" src="images/RTS_GuiCollection.png" /></p>
                  <p><br />
                  	Delete the <strong>DamageHUD</strong> element and its children.  First, either select the Reticle object from the element tree on the right or click in the center of the GUI, then delete it.
                  </p>
                  <p>
                      <img alt="" src="images/RTS_DeleteDamageHUD.png" /></p>
                <p><br />
                	Delete the <strong>Reticle</strong> and <strong>ZoomReticle</strong> objects using the same methods.</p>
                  <p>
                      <img alt="" src="images/RTS_DeleteReticles.png" /></p>
                <p><br />
                      Now to add our simple build button.  Open the <strong>Library</strong> tab, pull down the 
                      <strong>Buttons</strong> rollout,&nbsp; then click and drag 
                      the <strong>GuiBitmapButtonCtrl</strong> onto the GUI to create a new button.</p>
                  <p>
                      <img alt="" src="images/RTS_GUIEditorLibraryTab.png" /></p>
                  <p><br />
                      Select your new button and change the settings as follows:</p>
                  <p>
                      <img alt="" src="images/RTS_GUIEditorButtonSettings.png" /></p>
                  <p>
                      <img alt="" src="images/RTS_GUIEditorButtonSettings2.png" /></p>
                  <p><br />
                      Save this image in your <strong>art/gui</strong> folder:</p>
                  <p>
                      <img alt="" src="images/InfantryIcon.png" /></p>
                  <p><br />
                      Browse to your project&#39;s <strong>art/gui</strong> folder and select the 
                      <strong>InfantryIcon.png</strong> file for 
                      the button image.</p>
                  <p><a href="images/RTS_SelectButtonImage.png" class="livethumbnail">
                      <img alt="" src="images/RTS_SelectButtonImage.png" width="433" height="260" largewidth="609" largeheight="442"/></a></p>
                  <p><br />
                      If you close the GUI Editor ( <strong>F10</strong> ) you should now see your 
                      button in the game UI.</p>
                  <p><a href="images/RTS_NewButtonScreenshot.png" class="livethumbnail">
                      <img alt="" src="images/RTS_NewButtonScreenshot.png" width="350" height="272" largewidth="715" largeheight="560" /></a></p>
                  <p><br />Next, open <strong>scripts/gui/playGui.cs</strong> and add the following code at 
                      the end:
                      </p>
                <pre>// onMouseDown is called when the left mouse
// button is clicked in the scene
// %pos is the screen (pixel) coordinates of the mouse click
// %start is the world coordinates of the camera
// %ray is a vector through the viewing 
// frustum corresponding to the clicked pixel
function PlayGui::onMouseDown(%this, %pos, %start, %ray)
{
    // If we're in building placement mode ask the server to create a building for
    // us at the point that we clicked.
    if (%this.placingBuilding)
    {
        // Clear the building placement flag first.
        %this.placingBuilding = false;
        // Request a building at the clicked coordinates from the server.
        commandToServer('createBuilding', %pos, %start, %ray);
    }
    else
    {
        // Ask the server to let us attack a target at the clicked position.
        commandToServer('checkTarget', %pos, %start, %ray);
    }
}

// This function is the callback that handles our new button.  When you click it
// the button tells the PlayGui that we're now in building placement mode.
function InfantryBld::onClick(%this)
{
    PlayGui.placingBuilding = true;
}
</pre>
                <p><br />
                    
                   Then, in <strong>scripts/server/commands.cs</strong> add the following function to the end:</p>

<pre>
function serverCmdcreateBuilding(%client, %pos, %start, %ray)
{
    createBuilding(%client, %pos, %start, %ray);
}

function createBuilding(%client, %pos, %start, %ray)
{
    // find end of search vector
    %ray = VectorScale(%ray, 2000);
    %end = VectorAdd(%start, %ray);

    // set up to look for the terrain
    %searchMasks = $TypeMasks::TerrainObjectType;

    // search!
    %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

    // If the terrain object was found in the scan
    if( %scanTarg )
    {
        // get the world position of the click
        %pos = getWords(%scanTarg, 1, 3);

        // Note:  getWord(%scanTarg, 0) will get the SimObject id of the object 
        // that the button click intersected with.  This is useful if you don't 
        // want to place buildings on certain other objects.  For instance, you 
        // could include TSStatic objects in your search masks and check to see 
        // what you clicked on - then don't place if it's another building.

        // spawn a new object at the intersection point
        %obj = new TSStatic()
        {
            position = %pos;
            shapeName = "art/shapes/station/station01.dts";
            collisionType = "Visible Mesh";
            scale = "0.5 0.5 0.5";
        };

        // find our nav mesh and update it so units will avoid the building
        // that we just placed:
        %navMesh = 0;
        %count = MissionGroup.getCount();
        for(%i = 0; %i < %count; %i++)
        {
            %missionObj = MissionGroup.getObject(%i);
            if(%missionObj.getClassName() $= "NavMesh")
            {
                %navMesh = %missionObj;
                break;
            }
        }
        if (%navMesh > 0)
            NavMeshUpdateOne(%navMesh, %obj);

        // Add the new object to the MissionCleanup group
        MissionCleanup.add(%obj);
    }
}</pre>
                <p><br />If you run the game now, you should be able to click the button, then click 
                    on the ground to place a new building.
                </p>
                <p><a href="images/RTS_PlaceBuilding.png" class="livethumbnail">
                    <img alt="" src="images/RTS_PlaceBuilding.png" width="308", height="181" largewidth="615" largeheight="363" /></a></p>
                <a name="Mouse-Driven_Input" id="Mouse-Driven_Input"></a>
                <h2> <span class="mw-headline">Mouse-Driven Input</span></h2>
                <p>Without FPS controls and player aiming, we need a new way to control
                  the Player object. The best examples of a mouse driven game genre are RTS
                  and Hack &amp; Slash. Typically, these game types allow you to move and
                  attack using the mouse buttons. Let's start with movement.  </p><br />
                <a name="Player_Spawning" id="Player_Spawning"></a>
                <h3> <span class="mw-headline">Player Spawning</span></h3>
                <p>At this point, we can spawn an AI player to stand in for the stock player using 
                    the default player class settings we&#39;ve provided in the 
                    DeathMatchGame::initGameVars() method.
                  This AI will be controlled by our mouse inputs. In addition, Torque 3D uses a
                  simple spawn system which can be easily modified to spawn any kind of
                  object (of any class).&nbsp; This section will demonstrate how to select what type 
                    of player or NPC you would like to spawn at a particular spawn point.</p>
                  <p><br />Open Toolbox, select the <b>empty terrain</b> level, then click the World Editor button. </p>
                <p><br />
                  Once you are in the editor, locate the spawn sphere in the 
                    scene. It is represented by a green octahedron, which will display a green
                  sphere when you click on it: </p>
                <br />
                <p><i>(click to enlarge)</i> </p>
                <a href="images/RTS_SpawnSphere.png" class="livethumbnail">
                  <img src="images/RTS_SpawnSphere.png" width="320" height="188" largewidth="640" 
                      largeheight="377" /></a><br />
                <p><br /><br />
                  You can also locate a spawn sphere by browsing the Scene Tree, under the PlayerDropPoints SimGroup: </p>
                <p><br />
                  <img alt="Image:RTS_SpawnSphere2.jpg" src="images/RTS_SpawnSphere2.png" 
                        border="0" /> </p>
                <p><br />
                  If you have multiple spawn spheres, delete all except for one. We can
                  control what type of actor is spawned by changing the properties of the
                  remaining spawn sphere. Select the sphere, then change the spawnClass
                  to <b>AIPlayer</b>. Also, change the name of the spawn sphere to <b>PlayerSpawn</b>.&nbsp; 
                    Technically this step is optional, but if you add other player types you will 
                    want to be able to specify who spawns where.&nbsp; This mechanism allows you to 
                    do that with minimal effort.</p>
                <p><br />
                  <img alt="Image:RTS_SpawnProperties.jpg" src="images/RTS_SpawnProperties.png" 
                        border="0" /> </p>
                  <p>This basically replicates the change we made in script earlier, but only for this 
                      specific spawn point.&nbsp; You could as easily used MyBossData for the 
                      spawnDatablock field and then that spawnpoint would spawn MyBoss objects.</p><br />
                <a name="Movement" id="Movement"></a>
                <h3> <span class="mw-headline">Movement</span></h3>
                <p>Now that we have an AI player spawning in the game, we can send it commands. Open <b>game/scripts/gui/playGui.cs</b>. Add the function <b>onRightMouseDown</b> as follows: </p>
                <pre>// onRightMouseDown is called when the right mouse
// button is clicked in the scene
// %pos is the screen (pixel) coordinates of the mouse click
// %start is the world coordinates of the camera
// %ray is a vector through the viewing 
// frustum corresponding to the clicked pixel
function PlayGui::onRightMouseDown(%this, %pos, %start, %ray)
{   
   commandToServer('movePlayer', %pos, %start, %ray);
}
</pre>
                <p><br />
                  At the end of <strong>scripts/server/commands.cs</strong> add the following:
                </p>
<pre>function serverCmdmovePlayer(%client, %pos, %start, %ray)
{
    movePlayer(%client, %pos, %start, %ray);
}

function movePlayer(%client, %pos, %start, %ray)
{
   //echo(" -- " @ %client @ ":" @ %client.player @ " moving");
   
   // Get access to the AI player we control
   %ai = %client.player;

   %ray = VectorScale(%ray, 1000);
   %end = VectorAdd(%start, %ray);

   // We want to allow the AI Player to walk on TSStatics, Interiors, Terrain, etc., so 
   // I broadened the search mask selection.
   %searchMasks = $TypeMasks::TerrainObjectType | $TypeMasks::StaticTSObjectType | 
       $TypeMasks::InteriorObjectType | $TypeMasks::ShapeBaseObjectType | 
       $TypeMasks::StaticObjectType;

   // search!
   %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

   // If the terrain object was found in the scan
   if( %scanTarg )
   {
      %pos = getWords(%scanTarg, 1, 3);
      // Get the normal of the location we clicked on
      %norm = getWords(%scanTarg, 4, 6);
      
      // Set the destination for the AI player to
      // make him move
      %ai.setPathDestination( %pos );
   }
}
</pre>
                <p><br />
                  Save your script and run the game. You should now be able to
                  direct the AI player to wherever you right-click on the terrain. This
                  only works if you have mouse look disabled, and your cursor is present
                  on screen. </p><br />
                <a name="Spawning_Enemy_Targets" id="Spawning_Enemy_Targets"></a>
                <h3> <span class="mw-headline">Spawning Enemy Targets</span></h3>
                <p>Our player looks lonely and bored. We should give him some targets, and the means of disposing of them. Open 
                    <b>game/scripts/client/default.bind.cs</b>, and add the following to the bottom of the file: </p>
                <pre>// Spawn an AI guy when key is pressed down
function spawnEnemy(%val)
{
   // If key was pressed down
   if(%val)
   {
      // Create a new, generic AI Player
      // Position will be at the camera's location
      // Datablock will determine the type of actor
      %enemy = new AIPlayer() 
      {
         position = LocalClientConnection.camera.getPosition();
         datablock = "DemoPlayer";
      };
      %game.loadOut(%enemy);
   }
}
// Bind the function spawnEnemy to the keyboard 'b' key
moveMap.bind(keyboard, b, spawnEnemy);
</pre>
                <p><br />
                  In the above code, a new example of accessing a client
                  connection is shown. Instead of ClientGroup, the code uses
                  LocalClientConnection. In a "single player" environment, you can use
                  these two interchangeably. Due to Torque 3D's architecture, there will
                  always be a server and at least one client connection. </p>
                <p><br />
                  The common practice for choosing which to use is as follows: </p>
                <ul>
                  <li><b>Accessing From A Client</b> - Use LocalClientConnection. This will always access your connection, player, camera, etc. </li>
                </ul>
                <ul>
                  <li><b>Accessing From Server</b> - Use
                    ClientGroup.getObject(%index). Multiple connections to choose from.
                    This is good for applying the same functionality to all connections, or
                    isolating specific ones based on ID. </li>
                </ul>
                <p><br />
                  Again, do not forget to delete <b>game/scripts/client/config.cs</b>.
                  You can run the game, then press the 'b' key to spawn stationary AI
                  targets in the same position as your camera. If gravity is enabled,
                  they will fall until they hit the terrain. </p><br />
                <a name="Attacking" id="Attacking"></a>
                <h3> <span class="mw-headline">Attacking</span></h3>
                <p>Currently, we have a player we can control, and targets that can die. Let's give the player some combat skills. In <b>game/scripts/server/commands.cs</b>, add the following 
                    two functions to the bottom of the script: </p>
                <pre>function serverCmdcheckTarget(%client, %pos, %start, %ray)
{
    %player = %client.player;

    %ray = VectorScale(%ray, 1000);
    %end = VectorAdd(%start, %ray);

    // Only care about players this time
    %searchMasks = $TypeMasks::PlayerObjectType;

    // Search!
    %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

    // If an enemy AI object was found in the scan
    if( %scanTarg )
    {
        // Get the enemy ID
        %target = firstWord(%scanTarg);
        if(%player != %target)
        {
            // Cause our AI object to aim at the target
            // offset to half unit height so you don't aim at the target's feet
            %datablock = %target.getDatablock();
            %offset = "0 0 "@%datablock.boundingBox.z / 2;
            %player.setAimObject(%target, %offset);
            %player.target = %target;

            // Tell our AI object to fire its weapon
            %player.setImageTrigger(0, 1);
        }
        else
        {
            stopAttack(%client);
        }
    }
    else
    {
        stopAttack(%client);
    }
}

function stopAttack(%client)
{
    // If no valid target was found, or left mouse
    // clicked again on terrain, stop firing and aiming
    %unit = %client.player;
    %unit.setAimObject(0);
    %unit.schedule(150, "setImageTrigger", 0, 0);
}

function serverCmdstopAttack(%client)
{
    stopAttack(%client);
}</pre>
<p><br />
Open <strong>scripts/server/weapon.cs</strong> and in <strong>WeaponImage::onFire()</strong> and update it to this:</p>
<pre>function WeaponImage::onFire(%this, %obj, %slot)
{
    //echo("\c4WeaponImage::onFire( "@%this.getName()@", "@%obj.client.nameBase@", "@%slot@" )");

    // Make sure we have valid data
    if (!isObject(%this.projectile))
    {
        error("WeaponImage::onFire() - Invalid projectile datablock");
        return;
    }

    // Decrement inventory ammo. The image's ammo state is updated
    // automatically by the ammo inventory hooks.
    if ( !%this.infiniteAmmo )
        %obj.decInventory(%this.ammo, 1);

    // Get the player's velocity, we'll then add it to that of the projectile
    %objectVelocity = %obj.getVelocity();

    %numProjectiles = %this.projectileNum;
    if (%numProjectiles == 0)
        %numProjectiles = 1;

    if (%obj.isMemberOfClass("AIPlayer") && isObject(%obj.target))
    {
        %vec = %obj.getVectorTo(%obj.target.position);
        if(%obj.aimOffset)
            %vec = VectorAdd(%vec, "0 0 "@%obj.aimOffset);
        %vec = VectorNormalize(%vec);
    }
    else
    {
        // getting the straight ahead aiming point of the gun
        %vec = %obj.getMuzzleVector(%slot);
    }

    for (%i = 0; %i < %numProjectiles; %i++)
    {
        if (%this.projectileSpread)
        {
            // We'll need to "skew" this projectile a little bit.  We start by
            // Then we'll create a spread matrix by randomly generating x, y, and z
            // points in a circle
            %matrix = "";
            for(%j = 0; %j < 3; %j++)
                %matrix = %matrix @ (getRandom() - 0.5) * 2 * 3.1415926 * %this.projectileSpread @ " ";
            %mat = MatrixCreateFromEuler(%matrix);

            // Which we'll use to alter the projectile's initial vector with
            %muzzleVector = MatrixMulVector(%mat, %vec);
        }
        else
        {
            // Weapon projectile doesn't have a spread factor so we fire it using
            // the straight ahead aiming point of the gun
            %muzzleVector = %vec;
        }

        // Add player's velocity
        %muzzleVelocity = VectorAdd(
        VectorScale(%muzzleVector, %this.projectile.muzzleVelocity),
        VectorScale(%objectVelocity, %this.projectile.velInheritFactor));

        // Create the projectile object
        %p = new (%this.projectileType)()
        {
            dataBlock = %this.projectile;
        };
        %p.initialVelocity = %muzzleVelocity;
        %p.initialPosition = %obj.getMuzzlePoint(%slot);
        %p.sourceObject = %obj;
        %p.sourceSlot = %slot;
        %p.client = %obj.client;
        %p.sourceClass = %obj.getClassName();
        MissionCleanup.add(%p);
    }
}</pre>
<p>Next, open <strong>scripts/server/aiPlayer.cs</strong> and add this method:</p>
<pre>// Return position vector to a position
/// <summary>
/// This function calculates the vector to %pos from eye point
/// <summary>
/// <param name="pos">The target position.</param>
/// <return>Returns a 3D vector from eye pos to target pos (not normalized).</return>
function AIPlayer::getVectorTo(%this, %target)
{
    if (getWordCount(%pos) < 2 && isObject(%target))
        %pos = %target.getPosition();

    %z = getWord(%this.boundingBox, 2) / 2;
    %offset = "0 0" SPC %z;
    
    %vec = VectorAdd(%offset, %this.getPosition());

    %z = getWord(%target.boundingBox, 2) / 2;
    %offset = "0 0" SPC %z;
    
    %pos = VectorAdd(%offset, %pos);
    
    return VectorSub(%pos, %vec);
}</pre>
<p><br />
Now, your player will continuously shoot at any other player you left click on (accuracy not guaranteed). Press the 'b' key to spawn targets to shoot at and blast away. The AI player will be locked in auto-fire mode until you left click on the terrain or on another target. or on another target.</p>
                <p><br />
                  We now have the base functionality for moving the player and the camera, selecting a target, and attacking is now complete.</p><br />
                <a name="Tweaking_Attacks" id="Tweaking_Attacks"></a>
                <h3> <span class="mw-headline">Tweaking Attacks</span></h3>
                <p>You might have noticed some flaws with the base code: </p>
                <ul>
                  <li>The first shot usually misses </li>
                  <li>AI only fires a single shot at a time </li>
                  <li>Enemy may not appear to &quot;die&quot; when health reaches 0</li>
                </ul>
                <p><br />
                  We are going to try and correct these one at a time using
                  TorqueScript and the editors. Let's start by making our first shot be
                  on target. The reason the first shot may miss entirely is because the
                  AI is firing before it has fully turned to aim at the target. </p>
                <p><br />
                    To fix this, edit <b>scripts/server/commands.cs.</b>, scroll down to the <strong>
                    serverCmdcheckTarget()</strong> function, and locate the following line of code: </p>
                <pre>// Tell our AI object to fire its weapon
%player.setImageTrigger(0, 1);
</pre>
                <p><br />
                  Replace the above code with the following: </p>
                <pre>// Tell our AI object to fire its weapon in 100 milliseconds
%player.schedule(100, "setImageTrigger", 0, 1);
                </pre>
                <p><br />
                  Remember, the %ai variable contains a handle to our AI player
                  object. The AIPlayer object, which is a child class of SimObject, can
                  make use of a method named <b>schedule.</b> Instead of calling the setImageTrigger function immediately, we can schedule it to go off in delayed manner. </p>
                <p><br />
                  <b>Schedule (ConsoleMethod) Parameters</b> </p>
                <pre>simObject.schedule(time, command, arg1...argN)</pre>
                <ul>
                  <li><b>time</b> - Number of milliseconds to wait before calling the command. </li>
                </ul>
                <ul>
                  <li><b>command</b> - Member function (belonging to the simObject using schedule) to call </li>
                </ul>
                <ul>
                  <li><b>arg1...argN</b> - Parameters, comma separated, to pass into the command. </li>
                </ul>
                <p><br />
                  The AI we control should now have time to turn and face the target
                  before firing off the first shot. The code is currently delayed by 100
                  milliseconds, so you can adjust that number based on desired
                  performance. </p>
                <p><br />
                  Next, we will change the auto-fire behavior. Instead of having the AI
                  constantly attack a target, even after it is dead, we are going to
                  modify the code to only cause our player to attack when a mouse button
                  is clicked. In the same function we were just working in, locate the
                  first schedule line we created </p>
                <pre>// Tell our AI object to fire its weapon in 100 milliseconds
%player.schedule(100, "setImageTrigger", 0, 1);
</pre>
                <p><br />
                  Then add the following directly under it: </p>
                <pre>// Stop firing in 150 milliseconds
%player.schedule(150, "setImageTrigger", 0, 0);
</pre>
                <p><br />
                  If you have not been saving after every script change, you
                  should definitely do so. Save, then run your game to test the changes
                  made to the attack routine. Your AI should now be facing the target on
                  the first shot, and only attack when you click on the target. </p>
                <p>
                <a name="Destination_Markers" id="Destination_Markers"></a>
                <h2> <span class="mw-headline">Destination Markers</span></h2>
                <p>In most RTS or Hack &amp; Slash games, some kind of marker is placed
                  on the ground where you clicked. This is usually a visual aid to let
                  you know the move assignment was given, the destination has been set,
                  and the AI is moving. . </p>
                <p><br />
                  We are going to add this functionality to our prototype to
                  make it easier to track our AI player using the Material Editor, Decal
                  Editor, and TorqueScript. First, we need to create a material for the
                  marker. </p><br />
                <a name="Creating_a_Material" id="Creating_a_Material"></a>
                <h3> <span class="mw-headline">Creating a Material</span></h3>
                <p>To get started on our marker creation, run your project in the <strong>World Editor</strong>. Next, open the 
                    <strong>Material Editor</strong>:</p>
                  <img src="images/RTS_MaterialEditor.png" border="0" /> </p>
<p>                     and click on the <i>Create New Material</i> button. </p>
                <p><br />
                  <img alt="Image:MarkerNewMaterialButton.jpg" 
                        src="images/RTS_MarkerNewMaterialButton.png" border="0" /> </p>
                <p><br />
                  At this point, the current material will be switched to an 
                    orange warning texture signifying that no diffuse map has been applied. Change the Material name to "gg_marker" and press enter to apply the
                  change. Next, click on the Diffuse Map box to open the file browser.
                  Navigate to the <b>game/art/decals</b> folder and select the g_marker.png file. This asset was given to you at the beginning of this guide: </p>
                <p><br />
                  <i>(click to enlarge)</i> </p>
                <a href="images/RTS_MarkerFile.png" class="livethumbnail">
                  <img src="images/RTS_MarkerFile.png" width="320" height="179" largewidth="640" 
                      largeheight="358" /></a><br />
                <p><br />
                  Your new material is nearly complete. However, you should notice that
                  the marker file and the material do not look the same. Compare the two: </p>
                <p><br />
                  <b>Marker File</b> </p>
                <p><img alt="Image:g_marker.png" src="images/destDecal.png" border="0" height="253" width="253" /> </p>
                <p>You can download this image to use by right-clicking and selecting "save image as" from the context menu.</p>
                <p><br />
                  <b>Material</b> </p>
                <p><img alt="Image:gMaterialBefore.jpg" src="images/RTS_GMaterialBefore.png" 
                        border="0" /> </p>
                <p><br />
                  This is easy to fix. While editing the gg_marker material,
                  go to the very bottom in the Advanced Properties section and make the indicated 
                    changes:<br /></p>
                <p>
                  <img alt="Image:toggleAlphaThreshold.jpg" 
                        src="images/RTS_ToggleAlphaThreshold.png" border="0" /> </p>
                <p><br />
                  This will immediately change the material preview.&nbsp; If you see something like 
                    the following, don&#39;t worry; this will probably look fine when we apply it to the 
                    decal.</p>
                  <p>
                      <img alt="" dir="ltr" src="images/RTS_DecalMaterialPreview.png" /></p>
                <p><br />
                  You are finished with the material. Click save the save button, which will write out the following data to <b>game/art/material.cs:</b> </p>
                <pre>singleton Material(DECAL_destDecal)
{
   mapTo = "unmapped_mat";
   diffuseMap[0] = "art/decals/destDecal.png";
   castShadows = "0";
   translucent = "1";
   translucentZWrite = "1";
   alphaTest = "1";
   alphaRef = "80";
   showFootprints = "0";
   materialTag0 = "Miscellaneous";
};
</pre>
                <a name="Creating_a_Decal" id="Creating_a_Decal"></a>
                <h3> <span class="mw-headline">Creating a Decal</span></h3>
                <p>To create a marker decal, run the <strong>World Editor</strong> and then open the
                    <strong>Decal Editor</strong>. </p>
                  <p>
                      <img alt="" src="images/RTS_DecalEditorButton.png" /></p>
                  <p>Click on the <i>New Decal Data</i> button (
                    <img alt="" src="images/btn_new.png" /> ), next to the garbage bin 
                    ( <img src="images/btn_delete.png" /> ), and name your new entry "gg_decal". </p>
                <p>
                    <img alt="" src="images/RTS_NewDecalButton.png" /><br />
                  <img alt="Image:MarkerNewDecal.jpg" src="images/RTS_MarkerNewDecal.png" 
                        border="0" /> </p>
                <p><br />
                  Next, click on the box in the Material Field of the decal properties, as shown below: </p>
                  <p>
                      <img alt="" src="images/RTS_SelectDecalMaterial.png" /></p>
                <p><br />
                  This should open the Material Selector. Locate the gg_maker material we created earlier, click on it, then press the <i>Select</i> button: </p>
                <p><br />
                  <i>(click to enlarge)</i> </p>
                <a href="images/RTS_SelectGGMarker.png" class="livethumbnail">
                  <img src="images/RTS_SelectGGMarker.png" width="320" height="231" largewidth="640" largeheight="463" /></a><br />
                <p><br />
                  The Decal Editor's preview box will display what your new decal will look like in the scene. </p>
                <p><br />
                  <img src="images/RTS_GGDecalComplete.png" /></a><br />
                <p><br />
                  That's all that needs to be done to create the decal. Save your level, and your decal data will automatically be written out to <b>game/art/decals/managedDecalData.cs</b>: </p>
                <pre>datablock DecalData(gg_decal)
{
   textureCoordCount = "0";
   Material = "gg_marker";
};
</pre><br />
                <a name="Spawning_the_Marker" id="Spawning_the_Marker"></a>
                <h3> <span class="mw-headline">Spawning the Marker</span></h3>
                <p>Now that we have a destination marker, we need to add it upon
                  clicking on the terrain and then delete it when our player reaches its
                  destination. Start by opening <b>scripts/client/client.cs</b>. At the end of this file, add the following code: </p>
                <pre>function clientCmdsetDestDecal(%unit, %position, %norm)
{
    // If the AI player already has a decal (0 or greater)
    // tell the decal manager to delete the instance of the gg_decal
    if(%unit.decal > -1)
    {
        decalManagerRemoveDecal(%unit.decal);
    }

    // Create a new decal using the decal manager
    // arguments are (Position, Normal, Rotation, Scale, Datablock, Permanent)
    // AddDecal will return an ID of the new decal, which we will
    // store in the player
    %unit.decal = decalManagerAddDecal(%position, %norm, 0, 1, "destDecal", true);
}</pre>
<p><br />
Then, in <strong>scripts/server/commands.cs</strong>, modify <strong>movePlayer()</strong> to tell the client to spawn the decal:</p>
<pre>
    // .... 
    // If the terrain object was found in the scan
    if( %scanTarg )
    {
	    %pos = getWords(%scanTarg, 1, 3);
    	// Get the normal of the location we clicked on
	    %norm = getWords(%scanTarg, 4, 6);
    
        // Set the destination for the AI player to
        // make him move
        %ai.setPathDestination( %pos );
        
        // add this!
        commandToClient(%client, 'setDestDecal', %ai, %pos, %norm);
    }
</pre>
                <p><br />
                  Save your script, then run the game. When you right click on the
                  terrain, the GarageGames symbol should render as a decal at the
                  destination. </p>
                <p><br />
                <img src="images/RTS_MarkerDestination.png" /></a><br /><br /><br />
                <a name="Erasing_the_Marker" id="Erasing_the_Marker"></a>
                <h3> <span class="mw-headline">Erasing the Marker</span></h3>
                <p>The last thing we need to do is erase the destination marker when our AI player gets to it. Open the <b>scripts/server/aiPlayer.cs</b> file, then add the following to the end of <strong>DemoPlayer::onReachDestination()</strong>: </p>
                <pre>
   if( %obj.decal &gt; -1 )
      decalManagerRemoveDecal(%obj.decal);
</pre>
                <p><br />
                  Now, when the AI player reaches its destination the marker will be deleted. </p><br />
                <a name="Camera_Modes" id="Camera_Modes"></a>
                <h2> <span class="mw-headline">Camera Modes</span></h2>
                <p>Now that you've got control of your character, it's time to discuss the camera controls.&nbsp;We&#39;ve 
                    decided on a two-mode approach so that you can use the Overhead mode to observe 
                    the battlefield and the OrbitObject mode so that you can follow a specific unit.</p>
                  <br />
                <a name="Orbit_Camera" id="Orbit_Camera"></a>
                <h3> <span class="mw-headline">Orbit Camera</span></h3>
                <p><br />Open the <strong>scripts/server/commands.cs</strong> script and find the
                    <strong>serverCmdorbitCam()</strong> function:</p>
                <pre>function serverCmdorbitCam(%client)
{
    orbitCam(%client);
}

function orbitCam(%client)
{
    %client.camera.setOrbitObject(%client.player, mDegToRad(20) SPC "0 0", 0, 5.5, 5.5);
    %client.camera.camDist = 5.5;
    %client.camera.controlMode = "OrbitObject";
}</pre>
                <p><br />
                  Lets break this command down.
                    %client.camera.setOrbitObject() puts the camera into OrbitObject mode. The first 
                    argument is the object to orbit around.&nbsp; %client is provided by our caller 
                    when the server command is called.&nbsp; </p>
                <p><br />
                  The second argument is a vector representing the angle of
                  the camera in (x, y, z) or (pitch, roll, yaw) if you prefer. Here it is
                  pitched 20 degrees down, with 0 roll and 0 yaw. </p>
                <p><br />
                  The next three arguments are the allowed distances from the target: min
                  distance, max distance and current distance: here 0, 5.5 and 5.5
                  respectively. The last two arguments should be sent as floating point numbers or 
                    odd results can occur.&nbsp; This function may take additional optional parameters: an
                  ownership flag denoting if the object orbited by the camera belongs to
                  the camera's client, an offset if the camera should focus
                  somewhere other than the object's center, and a flag specifying if the
                  camera should be locked. </p>
                  <p><br />The next line sets the camera distance from the orbit target to 5.5 units. </p>
                  <p><br />The final line sets the controlMode to OrbitObject.</p>
                  <br />
                <a name="Overhead_Camera" id="Overhead_Camera"></a>
                <h3> <span class="mw-headline">Overhead Camera</span></h3>
                <p>Cameras used by RTS games are slightly different from the Hack &amp; Slash or Fly 
                    cameras. They are characterized by a camera that moves laterally along the x and 
                    y axis, but generally not in z. This can be realized in T3D by using the 
                    &quot;Overhead&quot; camera mode.</p>
                  <p><br />In <strong>scripts/server/commands.cs</strong> find the <strong>
                      serverCmdoverheadCam()</strong> function:</p>
                <pre>function serverCmdoverheadCam(%client)
{
    overheadCam(%client);
}

function overheadCam(%client)
{
    %client.camera.position = VectorAdd(%client.player.position, "0 0 30");
    %client.camera.lookAt(%client.player.position);
    %client.camera.controlMode = "Overhead";
}</pre>
                <p><br />
                  With this setup, the camera will be free to move around with the
                  standard "wasd" controls, but it will not move vertically in the world.
                  By default the &#39;e&#39; key should move the camera up and the &#39;c&#39; key 
                    should move the camera down if you want to adjust the camera&#39;s height above the 
                    terrain. </p>
                <p><br />
                    For the traditional RTS players who wish to use the mouse
                  wheel, we implemented mouse wheel zoom in this function from the Camera Setup 
                    section (<strong>scripts/server/commands.cs</strong>): </p>
                <pre>// Adjusts the height of the camera using the mouse wheel
function serverCmdadjustCamera(%client, %adjustment)
{
    adjustCamera(%client, %adjustment);
}

function adjustCamera(%client, %adjustment)
{
    if(%client.camera.controlMode $= "OrbitObject")
    {
        if(%adjustment == 1)
            %n = %client.camera.camDist + 0.5;
        else
            %n = %client.camera.camDist - 0.5;
        
        if(%n < 0.5)
            %n = 0.5;
        
        if(%n > 15.0)
            %n = 15.0;
        
        %client.camera.setOrbitObject(%client.player, %client.camera.getRotation(), 0, %n, %n);
        %client.camera.camDist = %n;
    }
    if(%client.camera.controlMode $= "Overhead")
        %client.camera.position = VectorAdd(%client.camera.position, "0 0" SPC %adjustment);
}
</pre>
                <p>Notice that this function catches the camera mode and uses an appropriate method 
                    for adjusting the camera&#39;s position by checking the <strong>controlMode</strong> 
                    member&#39;s value.</p>
                <p><br />
                    In the
                  above code, we are sticking to the client/server architecture of Torque
                  3D. Typically, actions such as navigating through GUIs, rendering, and
                  input are handled on the client. However, when actions have an effect
                  on the game, they should be performed on the server. </p>
                <p><br />
                  Camera location can usually be handled as a client operation, but this
                  is a good opportunity to show off the client/server communication. Also, in 
                    multiplayer games it is important to remember that the server scopes visibility 
                    for the clients. Camera position should stay in sync to ensure that this scoping 
                    is accurate.&nbsp; The
                  default.bind.cs is a client script, which contains the client function
                  mouseZoom(...). This is only called when there is a client action, such
                  as the mouse wheel input. </p>
                <p><br />
                  Once the client action has been performed, a message is
                  sent to the server to act on it: <strong>commandToServer('adjustCamera',
                  -1);</strong>. The first parameter is the name of the server command/function to
                  call (minus the <strong>serverCmd</strong> prefix), and the rest of the parameters are arguments used by the command.
                  In this situation, based on the direction of the mouse wheel rotation a
                  positive or negative 1 will be sent to the server command which uses this value to adjust the camera. </p>
                <br />
                <p>Now that the functions are set up, all that is left is creating a key bind to call them. Back in 
                    <strong>default.bind.cs</strong> 
                    we added the following binding to the script:</p>
                  <pre>moveMap.bind( mouse, zaxis, mouseZoom );</pre>
                <br />
                <p>This allows you to zoom in and out on your actor using your mouse's scroll wheel 
                    in orbit mode and adjust camera height in overhead mode..</p>
                <p><br />
                  If you want to play around with the camera settings created in this tutorial, 
                  examine the following code that we added at the bottom of <strong>game/scripts/server/commands.cs</strong> in the 
                    <a href="#Camera_Setup">Camera Setup</a> section.</p>
<pre>
function serverCmdorbitCam(%client)
{
    orbitCam(%client);
}

function orbitCam(%client)
{
    %client.camera.setOrbitObject(%client.player, mDegToRad(20) SPC "0 0", 0, 5.5, 5.5);
    %client.camera.camDist = 5.5;
    %client.camera.controlMode = "OrbitObject";
}

function serverCmdoverheadCam(%client)
{
    overheadCam(%client);
}

function overheadCam(%client)
{
    %client.camera.position = VectorAdd(%client.player.position, "0 0 30");
    %client.camera.lookAt(%client.player.position);
    %client.camera.controlMode = "Overhead";
}

function serverCmdtoggleCamMode(%client)
{
    toggleCamMode(%client);
}

function toggleCamMode(%client)
{
    if(%client.camera.controlMode $= "Overhead")
        orbitCam(%client);
    else if(%client.camera.controlMode $= "OrbitObject")
        orbitCam(%client);
}

function serverCmdadjustCamera(%client, %adjustment)
{
    adjustCamera(%client, %adjustment);
}

function adjustCamera(%client, %adjustment)
{
    if(%client.camera.controlMode $= "OrbitObject")
    {
        if(%adjustment == 1)
            %n = %client.camera.camDist + 0.5;
        else
            %n = %client.camera.camDist - 0.5;
        
        if(%n < 0.5)
            %n = 0.5;
        
        if(%n > 15.0)
            %n = 15.0;
        
        %client.camera.setOrbitObject(%client.player, %client.camera.getRotation(), 0, %n, %n);
        %client.camera.camDist = %n;
    }
    if(%client.camera.controlMode $= "Overhead")
        %client.camera.position = VectorAdd(%client.camera.position, "0 0" SPC %adjustment);
}
</pre>
                <p><br />
                  You can call these functions using the usual <strong>commandToServer</strong> syntax. Just type the following in the console (press ~) </p>
<pre>
commandToServer('orbitCam');

commandToServer('overheadCam');
</pre><br />
                <a name="GoingRTS" id="A3"></a>
                <h2> <span class="mw-headline">Going More Real-Time Strategy</span></h2>
                <p>Here we&#39;re going to talk about what to do with that station.&nbsp; We need a 
                    place to get more friendly units and the station seems the logical place, but it 
                    needs a few adjustments to work.&nbsp; I&#39;m not going into resource costs or 
                    build times - we'll cover that in part 2 - we&#39;re just going to pop out a 
                    new friendly unit when you left-click on the station.</p>
<p><br />First, we'll overhaul <strong>GameCore::spawnPlayer()</strong> in <strong>scripts/server/gameCore.cs</strong>.  We need to ditch the vestigial player spawn that comes with the FPS stuff and just drop the new player's camera directly at a spawn point.  We're pretty much going to gut this since we don't need anything that has to do with setting up a player - just the client's camera.</p>
<pre>function GameCore::spawnPlayer(%game, %client, %spawnPoint, %noControl)
{
    //echo (%game @"\c4 -> "@ %game.class @" -> GameCore::spawnPlayer");

    if (isObject(%client.player))
    {
        // The client should not already have a player. Assigning
        // a new one could result in an uncontrolled player object.
        error("Attempting to create a player for a client that already has one!");
    }

    // Attempt to treat %spawnPoint as an object
    if (getWordCount(%spawnPoint) == 1 && isObject(%spawnPoint))
    {
        // Defaults
        %spawnClass      = $Game::DefaultPlayerClass;
        %spawnDataBlock  = $Game::DefaultPlayerDataBlock;

        // Overrides by the %spawnPoint
        if (isDefined("%spawnPoint.spawnClass"))
        {
            %spawnClass = %spawnPoint.spawnClass;
            %spawnDataBlock = %spawnPoint.spawnDatablock;
        }
        else if (isDefined("%spawnPoint.spawnDatablock"))
        {
            // This may seem redundant given the above but it allows
            // the SpawnSphere to override the datablock without
            // overriding the default player class
            %spawnDataBlock = %spawnPoint.spawnDatablock;
        }

        %spawnProperties = %spawnPoint.spawnProperties;
        %spawnScript     = %spawnPoint.spawnScript;

        %client.spawnCamera(%spawnPoint);
    }

    // If the player's client has some owned turrets, make sure we let them
    // know that we're a friend too.
    if (%client.ownedTurrets)
    {
        for (%i=0; %i<%client.ownedTurrets.getCount(); %i++)
        {
            %turret = %client.ownedTurrets.getObject(%i);
            %turret.addToIgnoreList(%player);
        }
    }

    if (!isDefined("%client.skin"))
    {
        // Get available skins
        %availableSkins = %spawnDataBlock.availableSkins; // TAB delimited list of skin names

        // Set skin based on client's team.  If client's team is not set, set it to 1
        if(%client.team $= "")
            %client.team = 1;
        %client.skin = addTaggedString( getField(%availableSkins, %client.team) );
    }

    if(!isObject(%client.TeamList))
    {
        %client.TeamList = new SimSet();
        MissionCleanup.add(%client.TeamList);
    }
    %client.TeamList.add(%player);

    // Give the client control of the camera if in the editor
    if( $startWorldEditor )
    {
        %control = %client.camera;
        %control.mode = "Fly";
        EditorGui.syncCameraGui();
    }
    else
    {
        %control = %client.camera;
        overheadCam(%client);
    }

    // Allow the player/camera to receive move data from the GameConnection.  Without this
    // the user is unable to control the player/camera.
    if (!isDefined("%noControl"))
        %client.setControlObject(%control);
    if (isObject(%spawnPoint))
        %control.setTransform(%spawnPoint.getTransform());
}
</pre>
<p><br />With this all we have to do is grab the spawn sphere in the mission editor and place it so that it is where we want our player camera to spawn.  Open the mission in the <strong>Mission Editor</strong> and select the spawn sphere:</p>
<p><br />
  <img alt="" src="images/RTS_SelectSpawnSphere.png" /></p>

<p><br />Now click <strong>Object</strong> in the menu, then find <strong>Drop Location > at Camera w/Rotation</strong> and click that.</p>
<p><br />
  <img alt="" src="images/RTS_DropAtLocWithRot.png" /></p>
<p><br />Finally, click <strong>Object</strong> and then click <strong>Drop Selection</strong>.</p>
<p><br />
  <img alt="" src="images/RTS_DropObject.png" /></p>
<p><br />The spawn sphere is now placed where the camera is and it is facing the same direction as the camera.  When the player enters the mission his camera will be placed at the spawn sphere's location with its rotation.</p>
<p><br />Now, we&#39;ll add some code to the <strong>serverCmdcheckTarget()</strong> function to handle spawning.  The function should look something like this:</p>
<pre>
function attack(%client, %unit)
{
    %target = %unit.getAimObject();
    if (%target.getState() $= "Dead")
    {
        %unit.setAimObject(0);
    }
    else
    {
        %unit.setImageTrigger(0, 1);
        %unit.schedule(64, "setImageTrigger", 0, 0);
        schedule(128, 0, "attack", %client, %unit, %target);
    }
}

function serverCmdcheckTarget(%client, %pos, %start, %ray)
{
	checkTarget(%client, %pos, %start, %ray);
}

function checkTarget(%client, %pos, %start, %ray)
{
    %ray = VectorScale(%ray, 1000);
    %end = VectorAdd(%start, %ray);

    // Add new typemasks to the search so we can find clicks on barracks too
    %searchMasks = $TypeMasks::PlayerObjectType | $TypeMasks::StaticTSObjectType
         | $TypeMasks::StaticObjectType;

    // Search!
    %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

    // If an enemy AI object was found in the scan
    if( %scanTarg )
    {
        // Get the enemy ID
        %target = firstWord(%scanTarg);
        if (%target.class $= "barracks")
        {
            spawnTeammate(%client, %target);
        }
        else if (%target.getClassName() $= "AIPlayer")
        {
            if (%target.team != 1)
            {
                // Cause our AI object to aim at the target
                // offset (0, 0, 1) so you don't aim at the target's feet

                if (isObject(%client.TeamList))
                {
                    %c = 0;
                    %unit = %client.TeamList.getObject(0);
                    while (isObject(%unit))
                    {
                        if (%unit.isSelected)
                        {
                            %unit.mountImage(Lurker, 0);
                            %targetData = %target.getDataBlock();
                            %z = getWord(%targetData.boundingBox, 2) * 2;
                            %offset = "0 0" SPC %z;
                            %unit.setAimObject(%target, %offset);

                            // Tell our AI object to fire its weapon
                            attack(%client, %unit);
                        }
                        %c++;
                        %unit = %client.TeamList.getObject(%c);
                    }
                }
            }
            else
            {
                if ($SelectToggled)
                {
                    multiSelect(%target);
                }
                else
                {
                    cleanupSelectGroup();
                    %target.isSelected = true;
                    %target.isLeader = true;
                }
            }
        }
        else
        {
            stopAttack(%client);
            if (!$SelectToggled)
                cleanupSelectGroup();
        }
    }
    else
    {
        stopAttack(%client);
        if (!$SelectToggled)
            cleanupSelectGroup();
    }
}
</pre>
<p>
    We've also added some support code for handling selection of multiple units and a little bit for 
    spawning new bots from our stations.
</p>
<p><br />
    We'll need to revisit <strong>serverCmdstopAttack()</strong> to handle our multi-select system, too.  It should look like this:
</p>
<pre>
function serverCmdstopAttack(%client)
{
    stopAttack(%client);
}

function stopAttack(%client)
{
    // If no valid target was found, or left mouse
    // clicked again on terrain, stop firing and aiming
    for (%c = 0; %c < %client.TeamList.getCount(); %c++)
    {
        %unit = %client.TeamList.getObject(%c);
        %unit.setAimObject(0);
        %unit.schedule(150, "setImageTrigger", 0, 0);
    }
}</pre>

                <p><br />
                    Next, we'll add some more server commands to help us with managing our army.&nbsp;&nbsp; 
                    Our first step is to extend our <strong>serverCmdcreateBuilding()</strong> function to include a 
                    new spawn point that is associated with the structure to use as our troop 
                    creation point.&nbsp; The new version should look like this:</p>

<pre>
function serverCmdcreateBuilding(%client, %pos, %start, %ray)
{
	createBuilding(%client, %pos, %start, %ray);
}

function createBuilding(%client, %pos, %start, %ray)
{
    // find end of search vector
    %ray = VectorScale(%ray, 2000);
    %end = VectorAdd(%start, %ray);

    %searchMasks = $TypeMasks::TerrainObjectType;

    // search!
    %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

    // If the terrain object was found in the scan
    if( %scanTarg )
            %obj = getWord(%scanTarg, 0);

        %pos = getWords(%scanTarg, 1, 3);

        // spawn a new object at the intersection point
        %obj = new TSStatic()
        {
            position = %pos;
            shapeName = "art/shapes/station/station01.dts";
            class = "barracks";
            collisionType = "Visible Mesh";
            scale = "0.5 0.5 0.5";
        };

        %navMesh = 0;
        %count = MissionGroup.getCount();
        for(%i = 0; %i < %count; %i++)
        {
            %missionObj = MissionGroup.getObject(%i);
            if(%missionObj.getClassName() $= "NavMesh")
            {
                %navMesh = %missionObj;
                break;
            }
        }
        if (%navMesh > 0)
            NavMeshUpdateOne(%navMesh, %obj);

        // Add the new object to the MissionCleanup group
        MissionCleanup.add(%obj);
        
        // Set up a spawn point for new troops to arrive at.
        if (!isObject(Team1SpawnGroup))
        {
            new SimGroup(Team1SpawnGroup)
            {
                canSave = "1";
                canSaveDynamicFields = "1";
                enabled = "1";
            };

            MissionGroup.add(Team1SpawnGroup);
        }
        
        %spawnName = "team1Spawn" @ %obj.getId();
        %point = new SpawnSphere(%spawnName)
        {
            radius = "1";
            dataBlock = "SpawnSphereMarker";
            spawnClass = $Game::DefaultPlayerClass;
            spawnDatablock = $Game::DefaultPlayerDataBlock;
        };
        %point.position = VectorAdd(%obj.getPosition(), "0 5 2");
        Team1SpawnGroup.add(%point);
        MissionCleanup.add(%point);
    }
}</pre>

                <p>
                    Next we'll add a function to spawn a new bot and equip it with a weapon and some ammo.
                </p>

<pre>function serverCmdspawnTeammate(%client, %source)
{
    spawnTeammate(%client, %source);
}

function spawnTeammate(%client, %source)
{
    // Create a new, generic AI Player
    // Position will be at the camera's location
    // Datablock will determine the type of actor
    %spawnName = "team1Spawn" @ %source.getId();

    // Defaults
    %spawnClass      = $Game::DefaultPlayerClass;
    %spawnDataBlock  = $Game::DefaultPlayerDataBlock;

    // Overrides by the %spawnPoint
    if (isDefined("%spawnName.spawnClass"))
    {
     %spawnClass = %spawnName.spawnClass;
     %spawnDataBlock = %spawnName.spawnDatablock;
    }
    else if (isDefined("%spawnName.spawnDatablock"))
    {
     // This may seem redundant given the above but it allows
     // the SpawnSphere to override the datablock without
     // overriding the default player class
     %spawnDataBlock = %spawnName.spawnDatablock;
    }

    %spawnProperties = %spawnName.spawnProperties;
    %spawnScript     = %spawnName.spawnScript;

    // Spawn with the engine's Sim::spawnObject() function
    %newBot = spawnObject(%spawnClass, %spawnDatablock, "",
                        %spawnProperties, %spawnScript);

    %spawnLocation = GameCore::pickPointInSpawnSphere(%newBot, %spawnName);
    %newBot.setTransform(%spawnLocation);
    %newBot.team = 1;

    %newBot.clearWeaponCycle();

    %newBot.setInventory(Lurker, 1);
    %newBot.setInventory(LurkerClip, %newBot.maxInventory(LurkerClip));
    %newBot.setInventory(LurkerAmmo, %newBot.maxInventory(LurkerAmmo));
    %newBot.addToWeaponCycle(Lurker);

    if (%newBot.getDatablock().mainWeapon.image !$= "")
    {
        %newBot.mountImage(%newBot.getDatablock().mainWeapon.image, 0);
    }
    else
    {
        %newBot.mountImage(Lurker, 0);
    }
    
    // This moves our new bot away from the front door a ways to make room for 
    // other bots as we spawn them.
    %x = getRandom(-10, 10);
    %y = getRandom(4, 10);
    %vec = %x SPC %y SPC "0";
    %dest = VectorAdd(%newBot.getPosition(), %vec);
    %newBot.setPathDestination(%dest);
    
    addTeam1Bot(%newBot);
}</pre>

                <p>
                    We also need our <strong>addTeam1Bot()</strong> support function:
                </p>

<pre>
function addTeam1Bot(%bot)
{
    // We'll create a SimSet to track our Team1 bots if it hasn't been created already
    if (!isObject(%client.TeamList))
    {
        %client.TeamList = new SimSet();
        MissionCleanup.add(%client.TeamList);
    }
    
    // And then add our bot to the Team1 list.
    %client.TeamList.add(%bot);
}</pre>

                <p>
                    At this point we're ready to spawn units from our structures.&nbsp;&nbsp; If you 
                    test the game now, you should be able to create a new station and it should spawn 
                    bots when you click on it.</p>
                  <p><br />
                      <img alt="" src="images/RTS_SpawnBotsFromBuilding.png" /></p>
                <p><br />
                    A real-time strategy game isn&#39;t much unless you can select and direct your 
                    units.&nbsp; Next, we&#39;ll add a few more server commands and a client command to 
                    help with selecting and moving single and multiple units.</p>
                <p><br />
                    First we&#39;ll add the ability to &quot;select&quot; multiple units.&nbsp;&nbsp; 
                    Still in <strong>scripts/server/commands.cs</strong>, add the following 
                    functions:</p>

<pre>
function serverCmdtoggleMultiSelect(%client, %flag)
{
    if (%flag)
        $SelectToggled = true;
    else
        $SelectToggled = false;
}

function multiSelect(%target)
{
    if (!isObject(%client.TeamList))
    {
        %client.TeamList = new SimSet();
        MissionCleanup.add(%client.TeamList);
    }
    
    %leader = findTeamLeader(%client);
    if (isObject(%leader))
    {
        %target.destOffset = VectorSub(%leader.getPosition(), %target.getPosition());
    }
    else
    {
        %target.destOffset = "0 0 0";
        %target.isLeader = true;
    }

    %target.isSelected = true;
}

function findTeam1Leader()
{
    if (!isObject(%client.TeamList))
    {
        %client.TeamList = new SimSet();
        MissionCleanup.add(%client.TeamList);
    }

    for (%c = 0; %c < %client.TeamList.getCount(); %c++)
    {
        %unit = %client.TeamList.getObject(%c);
        if (%unit.isLeader)
            return %unit;
    }

    return 0;
}

function cleanupSelectGroup()
{
    if (!isObject(%client.TeamList))
    {
        %client.TeamList = new SimSet();
        MissionCleanup.add(%client.TeamList);
    }
    
    for (%c = 0; %c < %client.TeamList.getCount(); %c++)
    {
        %temp = %client.TeamList.getObject(%c);
        %temp.isSelected = false;
        %temp.isLeader = false;
        %temp.destOffset = "0 0 0";
    }
}</pre>

                <p>
                    First, 
                    <strong>serverCmdtoggleMultiSelect()</strong> just takes a flag and sets a global variable to let 
                    the system know when we want to start adding units to our selection list.&nbsp; 
                    The <strong>multiSelect()</strong> function actually handles setting up&nbsp; 
                    the list by setting a member variable on the bot to indicate that it has been 
                    selected.&nbsp; Additionally, if there is no other bot in the %client.TeamList SimSet 
                    that is selected this bot is designated the &quot;leader.&quot;&nbsp; All of the 
                    subsequently selected bots will calculate offset destination targets based on 
                    this bot&#39;s destination.&nbsp; The <strong>findTeam1Leader()</strong> 
                    utility function just searches the %client.TeamList for a designated &quot;leader&quot; unit.&nbsp; 
                    Finally, the <strong>cleanupSelectGroup()</strong> utility function just clears the 
                    selection variables from all of %client.TeamList&#39;s members.
                </p>
                <p><br />
                    Next, modify <strong>PlayGui::onRightMouseDown()</strong> in <strong>scripts/gui</strong> so that it 
                    looks like the following:
                </p>

<pre>
function PlayGui::onRightMouseDown(%this, %pos, %start, %ray)
{   
    commandToServer('movePlayer', %pos, %start, %ray);
}</pre>
<p><br />
    In order to move our group of selected units together we'll have to update our <strong>movePlayer()</strong> function in <strong>scripts/server/commands.cs</strong> to 
    tell all of our units where to go.
</p>
<pre>
function movePlayer(%client, %pos, %start, %ray)
{
    //echo(" -- " @ %client @ ":" @ %client.player @ " moving");

    // Get access to the AI player we control
    %ai = findTeam1Leader();

    %ray = VectorScale(%ray, 1000);
    %end = VectorAdd(%start, %ray);

    // only care about terrain objects
    %searchMasks = $TypeMasks::TerrainObjectType | $TypeMasks::StaticTSObjectType | 
    $TypeMasks::InteriorObjectType | $TypeMasks::ShapeBaseObjectType | 
    $TypeMasks::StaticObjectType;

    // search!
    %scanTarg = ContainerRayCast( %start, %end, %searchMasks);

    // If the terrain object was found in the scan
    if( %scanTarg )
    {
        %pos = getWords(%scanTarg, 1, 3);
        // Get the normal of the location we clicked on
        %norm = getWords(%scanTarg, 4, 6);

        // Set the destination for the AI player to
        // make him move
        if (isObject(%client.TeamList))
        {
            %c = 0;
            %end = %client.TeamList.getCount();
            %unit = %client.TeamList.getObject(0);
            if(%ai $= "")
                %ai = %unit;
            while (isObject(%unit))
            {
                if (%unit.isSelected)
                {
                    %dest = VectorSub(%pos, %unit.destOffset);
                    %unit.setPathDestination( %dest );
                }
                %c++;
                if (%c < %end)
                    %unit = %client.TeamList.getObject(%c);
                else
                    %unit = 0;
            }
        }
        else
        {
            if (%ai !$= "")
                %ai.setPathDestination( %pos );
        }
        
        commandToClient(%client, 'setDestDecal', %ai, %pos, %norm);
    }
}
</pre>
            <p><br />
                
                Now we have to modify <strong>scripts/client/default.bind.cs</strong> to add some new functions 
                and a new bind right after our bind to spawn enemy targets.
            </p>

<pre>
function addSelect()
{
    $SelectToggled = true;
    commandToServer('toggleMultiSelect', true);
}

function dropSelect()
{
    $SelectToggled = false;
    commandToServer('toggleMultiSelect', false);
}

moveMap.bindCmd( keyboard, "ctrl x", "addSelect();", "dropSelect();" );
</pre>

            <p>
                Now we have <strong>ctrl-X</strong> bound to tell our system to toggle multi-selection
                via the <strong>addSelect()</strong> and <strong>dropSelect()</strong> functions 
                on make and break respectively.&nbsp; This key combination was chosen 
                arbitrarily and you can of course use any key you like.&nbsp; Note that at the 
                moment <strong>shift</strong> only catches the &quot;make&quot; (in other words, it only 
                catches the event when you press the key down) and not the &quot;break,&quot; so if&nbsp; 
                you use it you&#39;ll have to write the function to toggle between multi-selection 
                and single selection when shift is pressed.</p>
                  <p>
                      If you test things now you should be able to select multiple units after you 
                      have spawned them and right-click to send them all off together.&nbsp; Note that 
                      you will need to click somewhere very near the units&#39; pelvis node to actually 
                      select them.</p>
                  <p><br />
                      <img alt="" src="images/RTS_MultiSelectMoving.png" /></p>
                  <p><br />
                      If you use the &#39;b&#39; key to spawn a target and then left-click on it while 
                      multiple units are selected they will all attack the target.&nbsp; The units should stop attacking when the target is dead.&nbsp; Left-clicking the 
                      terrain will also clear your current selection group.</p>
                  <p><br />
                      <img alt="" src="images/RTS_MultiSelectAttacking.png" /></p>
            <p><br />
                That about wraps it up.  You should now have a pretty functional RTS prototype with unit control, unit spawning and some 
                other basic features that are typical of the genre.
            </p>

<br />
                <a name="Conclusion" id="Conclusion"></a>
                <h2> <span class="mw-headline">Conclusion</span></h2>
                <p>The purpose of this tutorial was to show you some of the more
                  advanced capabilities of TorqueScript, and combine the language with
                  Torque 3D's visual editors to create a prototype game. As you just
                  experienced, getting a non-FPS prototype game started does not take
                  long. </p>
                <p><br />
                  Make sure you have read through all the comments
                  accompanying the new code, as they are part of the tutorial. At this
                  point you can move on to other tutorials, or improve upon the code to
                  create something more unique. There is always room for improvement,
                  such as: </p>
                <ul>
                  <li>Changing the units&#39; weapons out for rocket launchers or grenades</li>
                  <li>Make the targets move around and attack the player or the players units</li>
                  <li>Add key bindings to change camera modes on the fly</li>
                </ul><br />
                  <p><br />A special thanks to Michael Perry for the original RTS Prototype article and Steve Acaster for his 
                      <a href="http://www.garagegames.com/community/resources/view/20995" 
                          class="external">Tactics-Action Hybrid Game Tutorial 
                      series</a>, which saved me considerable time fiddling with the camera.</p>
                      
<p><br />
<a href="RTSPrototype2.html" target="mainFrame">Continue in part 2.</a></p>                
                </td>
            </tr>
          </tbody>
        </table>
        
        
        
        
    
  </div>
  
  </div>

</td></tr>

</table><div class="footer">   <a href="../../../content_welcome.html" target="">Home</a>   <a href="#">Back to Top</a></div>

</body>
<script type="text/javascript">

var links = document.getElementsByTagName('a');

for (var i = 0; i < links.length; i++)
	if (links[i].className == 'livethumbnail')
	{
		var img = links[i].getElementsByTagName('img')[0];		
		img.state = 'small';
		img.smallSrc = img.getAttribute('src');
		img.smallWidth = parseInt(img.getAttribute('width'));
		img.smallHeight = parseInt(img.getAttribute('height'));
		img.largeSrc = links[i].getAttribute('href');
		img.largeWidth = parseInt(img.getAttribute('largewidth'));
		img.largeHeight = parseInt(img.getAttribute('largeheight'));
		img.ratio = img.smallHeight / img.smallWidth;
		links[i].onclick = scale;
	}
	
function scale()
{
	var img = this.getElementsByTagName('img')[0];		
	img.src = img.smallSrc;
	
	if (! img.preloaded)
	{
		img.preloaded = new Image();
		img.preloaded.src = img.largeSrc;
	}

	var interval = window.setInterval(scaleStep, 10);
	return false;
	
	function scaleStep()
	{
		var step = 45;
		var width = parseInt(img.getAttribute('width'));
		var height = parseInt(img.getAttribute('height'));
		
		if (img.state == 'small')
		{
			width += step;
			height += Math.floor(step * img.ratio);
			
			img.setAttribute('width', width);
			img.setAttribute('height', height);
			
			if (width > img.largeWidth - step)
			{
				img.setAttribute('width', img.largeWidth);
				img.setAttribute('height', img.largeHeight);
				img.setAttribute('src', img.largeSrc);
				window.clearInterval(interval);
				img.state = 'large';
			}
		}
		else
		{
			width -= step;
			height -= Math.floor(step * img.ratio);

			img.setAttribute('width', width);
			img.setAttribute('height', height);
			
			if (width < img.smallWidth + step)
			{
				img.setAttribute('width', img.smallWidth);
				img.setAttribute('height', img.smallHeight);
				img.src = img.smallSrc;
				window.clearInterval(interval);
				img.state = 'small';
			}
		}
	}			
}

</script>
</html>
